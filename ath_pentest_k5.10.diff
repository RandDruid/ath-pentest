diff -rup linux-source-5.10/drivers/net/wireless/ath/ath9k/common-init.c linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/common-init.c
--- linux-source-5.10/drivers/net/wireless/ath/ath9k/common-init.c      2021-03-17 17:06:37.000000000 +0100
+++ linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/common-init.c      2021-06-07 09:07:18.506806073 +0200
@@ -22,14 +22,14 @@
        .band = NL80211_BAND_2GHZ, \
        .center_freq = (_freq), \
        .hw_value = (_idx), \
-       .max_power = 20, \
+       .max_power = 30, \
 }

 #define CHAN5G(_freq, _idx) { \
        .band = NL80211_BAND_5GHZ, \
        .center_freq = (_freq), \
        .hw_value = (_idx), \
-       .max_power = 20, \
+       .max_power = 30, \
 }

 /* Some 2 GHz radios are actually tunable on 2312-2732
diff -rup linux-source-5.10/drivers/net/wireless/ath/ath9k/htc_drv_main.c linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/htc_drv_main.c
--- linux-source-5.10/drivers/net/wireless/ath/ath9k/htc_drv_main.c     2021-03-17 17:06:37.000000000 +0100
+++ linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/htc_drv_main.c     2021-06-07 09:07:18.506806073 +0200
@@ -20,6 +20,12 @@
 /* Utilities */
 /*************/

+// CHANGES: module parameter to disable carrier sense
+int htc_carrier_sense_disable = 0;
+module_param_named(carrier_sense_disable, htc_carrier_sense_disable, int, 0444);
+MODULE_PARM_DESC(carrier_sense_disable, "Disable carrier sense");
+
+
 /* HACK Alert: Use 11NG for 2.4, use 11NA for 5 */
 static enum htc_phymode ath9k_htc_get_curmode(struct ath9k_htc_priv *priv,
                                              struct ath9k_channel *ichan)
@@ -215,6 +221,13 @@ void ath9k_htc_reset(struct ath9k_htc_pr
                        channel->center_freq, ret);
        }

+       //      CHANGES: disable physical carrier sense
+       if (htc_carrier_sense_disable) {
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_RX_CLEAR);
+               printk("!!! carrier sense disabled (ath9k_htc) !!!\n");
+       }
+
        ath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,
                               &priv->curtxpow);

@@ -283,6 +296,13 @@ static int ath9k_htc_set_channel(struct
                goto err;
        }

+       //      CHANGES: disable physical carrier sense
+       if (htc_carrier_sense_disable) {
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_RX_CLEAR);
+               printk("!!! carrier sense disabled (ath9k_htc) !!!\n");
+       }
+
        ath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,
                               &priv->curtxpow);

@@ -938,6 +958,13 @@ static int ath9k_htc_start(struct ieee80
                return ret;
        }

+       //      CHANGES: disable physical carrier sense
+       if (htc_carrier_sense_disable) {
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_RX_CLEAR);
+               printk("!!! carrier sense disabled (ath9k_htc) !!!\n");
+       }
+
        ath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,
                               &priv->curtxpow);

diff -rup linux-source-5.10/drivers/net/wireless/ath/ath9k/mac.c linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/mac.c
--- linux-source-5.10/drivers/net/wireless/ath/ath9k/mac.c      2021-03-17 17:06:37.000000000 +0100
+++ linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/mac.c      2021-06-07 09:07:18.506806073 +0200
@@ -18,6 +18,11 @@
 #include "hw-ops.h"
 #include <linux/export.h>

+// CHANGES: module parameter to disable carrier sense
+int hw_carrier_sense_disable = 0;
+module_param_named(carrier_sense_disable, hw_carrier_sense_disable, int, 0444);
+MODULE_PARM_DESC(carrier_sense_disable, "Disable carrier sense");
+
 static void ath9k_hw_set_txq_interrupts(struct ath_hw *ah,
                                        struct ath9k_tx_queue_info *qi)
 {
@@ -160,7 +165,8 @@ void ath9k_hw_abort_tx_dma(struct ath_hw
        }

        REG_CLR_BIT(ah, AR_PCU_MISC, AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF);
-       REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
+       if (hw_carrier_sense_disable == 0)
+               REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
        REG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);

        REG_WRITE(ah, AR_Q_TXD, 0);
diff -rup linux-source-5.10/drivers/net/wireless/ath/ath9k/main.c linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/main.c
--- linux-source-5.10/drivers/net/wireless/ath/ath9k/main.c     2021-03-17 17:06:37.000000000 +0100
+++ linux-source-5.10-patched/drivers/net/wireless/ath/ath9k/main.c     2021-06-07 09:18:03.891448702 +0200
@@ -22,6 +22,11 @@
 static void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
                        u32 queues, bool drop);

+// CHANGES: module parameter to disable carrier sense
+int ath_carrier_sense_disable = 0;
+module_param_named(carrier_sense_disable, ath_carrier_sense_disable, int, 0444);
+MODULE_PARM_DESC(carrier_sense_disable, "Disable carrier sense");
+
 u8 ath9k_parse_mpdudensity(u8 mpdudensity)
 {
        /*
@@ -331,6 +336,13 @@ static int ath_reset_internal(struct ath
                goto out;
        }

+       //      CHANGES: disable physical carrier sense
+       if (ath_carrier_sense_disable) {
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_RX_CLEAR);
+               printk("!!! carrier sense disabled (ath9k) !!!\n");
+       }
+
        if (ath9k_hw_mci_is_enabled(sc->sc_ah) &&
            sc->cur_chan->offchannel)
                ath9k_mci_set_txpower(sc, true, false);
@@ -686,6 +698,13 @@ static int ath9k_start(struct ieee80211_
                ah->reset_power_on = false;
        }

+       //      CHANGES: disable physical carrier sense
+       if (ath_carrier_sense_disable) {
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
+               REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_RX_CLEAR);
+               printk("!!! carrier sense disabled (ath9k) !!!\n");
+       }
+
        /* Setup our intr mask. */
        ah->imask = ATH9K_INT_TX | ATH9K_INT_RXEOL |
                    ATH9K_INT_RXORN | ATH9K_INT_FATAL |
diff -rup linux-source-5.10/drivers/net/wireless/ath/regd.c linux-source-5.10-patched/drivers/net/wireless/ath/regd.c
--- linux-source-5.10/drivers/net/wireless/ath/regd.c   2021-03-17 17:06:37.000000000 +0100
+++ linux-source-5.10-patched/drivers/net/wireless/ath/regd.c   2021-06-07 09:16:34.453316353 +0200
@@ -23,6 +23,16 @@
 #include "regd.h"
 #include "regd_common.h"

+// CHANGES: - changed frequency range to 2312-2732
+//          - allowed channel 12, 13 and 14 for all
+//          - removed 802.11b only restriction for channel 14
+//          - increased txpower to 30 in ATH9K_2GHZ_ ... REGRULES
+//         - always return 0 for radar detection
+
+char *user_country_name = "";                              // [MOD]
+module_param_named(cn, user_country_name, charp, S_IRUGO); // [MOD]
+MODULE_PARM_DESC(cn, "Country Name");                      // [MOD]
+
 static int __ath_regd_init(struct ath_regulatory *reg);

 /*
@@ -33,22 +43,16 @@ static int __ath_regd_init(struct ath_re
  */

 /* Only these channels all allow active scan on all world regulatory domains */
-#define ATH_2GHZ_CH01_11       REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+#define ATH_2GHZ_CH01_11       REG_RULE(2412-10, 2462+10, 40, 0, 30, 0)

 /* We enable active scan on these a case by case basis by regulatory domain */
-#define ATH_2GHZ_CH12_13       REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-                                        NL80211_RRF_NO_IR)
-#define ATH_2GHZ_CH14          REG_RULE(2484-10, 2484+10, 40, 0, 20,\
-                                        NL80211_RRF_NO_IR | \
-                                        NL80211_RRF_NO_OFDM)
+#define ATH_2GHZ_CH12_13       REG_RULE(2467-10, 2472+10, 40, 0, 30, 0)
+#define ATH_2GHZ_CH14          REG_RULE(2484-10, 2484+10, 40, 0, 20, 0)

 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH_5GHZ_5150_5350     REG_RULE(5150-10, 5350+10, 80, 0, 30,\
-                                        NL80211_RRF_NO_IR)
-#define ATH_5GHZ_5470_5850     REG_RULE(5470-10, 5850+10, 80, 0, 30,\
-                                        NL80211_RRF_NO_IR)
-#define ATH_5GHZ_5725_5850     REG_RULE(5725-10, 5850+10, 80, 0, 30,\
-                                        NL80211_RRF_NO_IR)
+#define ATH_5GHZ_5150_5350     REG_RULE(5150-10, 5350+10, 80, 0, 30, 0)
+#define ATH_5GHZ_5470_5850     REG_RULE(5470-10, 5850+10, 80, 0, 30, 0)
+#define ATH_5GHZ_5725_5850     REG_RULE(5725-10, 5850+10, 80, 0, 30, 0)

 #define ATH_2GHZ_ALL           ATH_2GHZ_CH01_11, \
                                ATH_2GHZ_CH12_13, \
@@ -77,10 +81,9 @@ static const struct ieee80211_regdomain
        .n_reg_rules = 4,
        .alpha2 =  "99",
        .reg_rules = {
-               ATH_2GHZ_CH01_11,
-               ATH_2GHZ_CH12_13,
-               ATH_5GHZ_NO_MIDBAND,
-       }
+                ATH_2GHZ_ALL,
+                ATH_5GHZ_ALL,
+       }
 };

 /* Can be used by 0x64 only */
@@ -88,9 +91,9 @@ static const struct ieee80211_regdomain
        .n_reg_rules = 3,
        .alpha2 =  "99",
        .reg_rules = {
-               ATH_2GHZ_CH01_11,
-               ATH_5GHZ_NO_MIDBAND,
-       }
+                ATH_2GHZ_ALL,
+                ATH_5GHZ_ALL,
+       }
 };

 /* Can be used by 0x66 and 0x69 */
@@ -98,9 +101,9 @@ static const struct ieee80211_regdomain
        .n_reg_rules = 3,
        .alpha2 =  "99",
        .reg_rules = {
-               ATH_2GHZ_CH01_11,
-               ATH_5GHZ_ALL,
-       }
+                ATH_2GHZ_ALL,
+                ATH_5GHZ_ALL,
+       }
 };

 /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
@@ -108,10 +111,9 @@ static const struct ieee80211_regdomain
        .n_reg_rules = 4,
        .alpha2 =  "99",
        .reg_rules = {
-               ATH_2GHZ_CH01_11,
-               ATH_2GHZ_CH12_13,
-               ATH_5GHZ_ALL,
-       }
+                ATH_2GHZ_ALL,
+                ATH_5GHZ_ALL,
+       }
 };

 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
@@ -180,7 +182,7 @@ static bool dynamic_country_user_possibl
        case CTRY_JAPAN57:
        case CTRY_JAPAN58:
        case CTRY_JAPAN59:
-               return false;
+               return true;
        }

        return true;
@@ -258,9 +260,10 @@ static bool ath_is_radar_freq(u16 center
                              struct ath_regulatory *reg)

 {
-       if (reg->country_code == CTRY_INDIA)
-               return (center_freq >= 5500 && center_freq <= 5700);
-       return (center_freq >= 5260 && center_freq <= 5700);
+//     if (reg->country_code == CTRY_INDIA)
+//             return (center_freq >= 5500 && center_freq <= 5700);
+//     return (center_freq >= 5260 && center_freq <= 5700);
+       return 0;
 }

 static void ath_force_clear_no_ir_chan(struct wiphy *wiphy,
@@ -697,7 +700,18 @@ static int __ath_regd_init(struct ath_re
        }

        regdmn = ath_regd_get_eepromRD(reg);
-       reg->country_code = ath_regd_get_default_country(regdmn);
+       reg->country_code = ath_regd_find_country_by_name(user_country_name); // [MOD]
+       if (reg->country_code != (u16) -1) {                                  // [MOD]
+           printk(KERN_DEBUG "ath: User Override Country Code\n");           // [MOD]
+       } else {                                                              // [MOD]
+           reg->country_code = ath_regd_get_default_country(regdmn);         // [MOD]
+            printk(KERN_DEBUG "ath: EEPROM country code: 0x%0x\n",
+                                reg->country_code);
+            printk(KERN_DEBUG "ath: Override Country Code with DEFAULT\n");   // [MOD]
+
+            reg->country_code = CTRY_DEFAULT;                                 // [MOD]
+            regdmn = CTRY_DEFAULT;                                            // [MOD]
+        }                                                                     // [MOD]

        if (reg->country_code == CTRY_DEFAULT &&
            regdmn == CTRY_DEFAULT) {
